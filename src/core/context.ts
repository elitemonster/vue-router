import { normalizeRoutesFolderOption, ResolvedOptions } from '../options'
import { createPrefixTree, TreeLeaf } from './tree'
import { promises as fs } from 'fs'
import { logTree, throttle } from './utils'
import { generateRouteNamedMap } from '../codegen/generateRouteMap'
import { MODULE_ROUTES_PATH, MODULE_VUE_ROUTER } from './moduleConstants'
import { generateRouteRecord } from '../codegen/generateRouteRecords'
import fg from 'fast-glob'
import { resolve } from 'pathe'
import { ServerContext } from '../options'
import { getRouteBlock } from './customBlock'
import { RoutesFolderWatcher, HandlerContext } from './RoutesFolderWatcher'

export function createRoutesContext(options: ResolvedOptions) {
  const { dts: preferDTS, root, routesFolder } = options
  const dts =
    preferDTS === false
      ? false
      : preferDTS === true
      ? resolve(root, 'typed-router.d.ts')
      : resolve(root, preferDTS)

  const routeTree = createPrefixTree(options)
  const routeMap = new Map<string, TreeLeaf>()

  function log(...args: any[]) {
    if (options.logs) {
      console.log(...args)
    }
  }

  // it's important to resolve the path before the watcher is created so it give full paths in the handler
  const resolvedRoutesFolders = normalizeRoutesFolderOption(routesFolder).map(
    (routeOption) => ({
      ...routeOption,
      src: resolve(root, routeOption.src),
    })
  )

  // populated by the initial scan pages
  const watchers: RoutesFolderWatcher[] = []

  async function scanPages() {
    if (options.extensions.length < 1) {
      throw new Error(
        '"extensions" cannot be empty. Please specify at least one extension.'
      )
    }

    // initial scan was already done
    if (watchers.length > 0) {
      return
    }

    const pattern =
      `**/*` +
      (options.extensions.length === 1
        ? options.extensions[0]
        : `.{${options.extensions
            .map((extension) => extension.replace('.', ''))
            .join(',')}}`)

    await Promise.all(
      resolvedRoutesFolders.map((folder) => {
        const watcher = new RoutesFolderWatcher(folder, options)
        setupWatcher(watcher)
        watchers.push(watcher)

        return fg(pattern, {
          cwd: folder.src,
          // TODO: do they return the symbolic link path or the original file?
          // followSymbolicLinks: false,
          ignore: options.exclude,
          // TODO: is this flat necessary?
        })
          .then((files) => files.map((file) => resolve(folder.src, file)))
          .then((files) =>
            Promise.all(
              files.map((file) =>
                addPage({
                  routePath: watcher.asRoutePath(file),
                  filePath: file,
                })
              )
            )
          )
      })
    )

    await _writeConfigFiles()
  }

  async function addPage({ filePath: path, routePath }: HandlerContext) {
    const routeBlock = await getRouteBlock(path, options)
    log(`added "${routePath}" for "${path}"`)
    if (routeBlock) log(routeBlock)
    // TODO: handle top level named view HMR
    const node = routeTree.insert(
      routePath,
      // './' + path
      resolve(root, path)
    )
    node.mergeCustomRouteBlock(routeBlock)
    routeMap.set(path, node)
  }

  async function updatePage({ filePath: path, routePath }: HandlerContext) {
    log(`updated "${routePath}" for "${path}"`)
    const node = routeMap.get(path)
    if (!node) {
      console.warn(`Cannot update "${path}": Not found.`)
      return
    }
    const routeBlock = await getRouteBlock(path, options)
    node.mergeCustomRouteBlock(routeBlock)
  }

  function removePage({ filePath: path, routePath }: HandlerContext) {
    log(`remove "${routePath}" for "${path}"`)
    routeTree.remove(routePath)
    routeMap.delete(path)
  }

  function setupWatcher(watcher: RoutesFolderWatcher) {
    log(`ü§ñ Scanning files in ${watcher.src}`)
    watcher
      .on('change', async (ctx) => {
        await updatePage(ctx)
        writeConfigFiles()
      })
      .on('add', async (ctx) => {
        await addPage(ctx)
        writeConfigFiles()
      })
      .on('unlink', async (ctx) => {
        await removePage(ctx)
        writeConfigFiles()
      })
  }

  function generateRoutes() {
    return `export const routes = ${generateRouteRecord(routeTree)}`
  }

  function generateDTS(): string {
    return `
// Generated by unplugin-vue-router. ‚ÄºÔ∏è DO NOT MODIFY THIS FILE ‚ÄºÔ∏è
// It's recommended to commit this file.
// Make sure to add this file to your tsconfig.json file as an "includes" or "files" entry.

/// <reference types="unplugin-vue-router/client" />

import type {
  // type safe route locations
  RouteLocationTypedList,
  RouteLocationResolvedTypedList,
  RouteLocationNormalizedTypedList,
  RouteLocationNormalizedLoadedTypedList,

  // helper types
  // route definitions
  RouteRecordInfo,
  ParamValue,
  ParamValueOneOrMore,
  ParamValueZeroOrMore,
  ParamValueZeroOrOne,

  // vue-router extensions
  _RouterTyped,
  RouterLinkTyped,
  NavigationGuard,
  UseLinkFnTyped,
} from 'unplugin-vue-router'

declare module '${MODULE_ROUTES_PATH}' {
${generateRouteNamedMap(routeTree)
  .split('\n')
  .filter((line) => line) // remove empty lines
  .map((line) => '  ' + line) // Indent by two spaces
  .join('\n')}
}

declare module '${MODULE_VUE_ROUTER}' {
  import type { RouteNamedMap } from '${MODULE_ROUTES_PATH}'

  export type RouterTyped = _RouterTyped<RouteNamedMap>

  /**
   * Type safe version of \`RouteLocationNormalized\` (the type of \`to\` and \`from\` in navigation guards).
   * Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocationNormalized<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationNormalizedTypedList<RouteNamedMap>[Name]

  /**
   * Type safe version of \`RouteLocationNormalizedLoaded\` (the return type of \`useRoute()\`).
   * Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocationNormalizedLoaded<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[Name]

  /**
   * Type safe version of \`RouteLocationResolved\` (the returned route of \`router.resolve()\`).
   * Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocationResolved<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationResolvedTypedList<RouteNamedMap>[Name]

  /**
   * Type safe version of \`RouteLocation\` . Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocation<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationTypedList<RouteNamedMap>[Name]

  /**
   * Generate a type safe params for a route location. Requires the name of the route to be passed as a generic.
   */
  export type RouteParams<Name extends keyof RouteNamedMap> = RouteNamedMap[Name]['params']
  /**
   * Generate a type safe raw params for a route location. Requires the name of the route to be passed as a generic.
   */
  export type RouteParamsRaw<Name extends keyof RouteNamedMap> = RouteNamedMap[Name]['paramsRaw']

  export function useRouter(): RouterTyped
  export function useRoute<Name extends keyof RouteNamedMap = keyof RouteNamedMap>(name?: Name): RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[Name]

  export const useLink: UseLinkFnTyped<RouteNamedMap>

  export function onBeforeRouteLeave(guard: NavigationGuard<RouteNamedMap>): void
  export function onBeforeRouteUpdate(guard: NavigationGuard<RouteNamedMap>): void
}

declare module 'vue-router' {
  import type { RouteNamedMap } from '${MODULE_ROUTES_PATH}'

  export interface TypesConfig {
    beforeRouteUpdate: NavigationGuard<RouteNamedMap>
    beforeRouteLeave: NavigationGuard<RouteNamedMap>

    $route: RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[keyof RouteNamedMap]
    $router: _RouterTyped<RouteNamedMap>

    RouterLink: RouterLinkTyped<RouteNamedMap>
  }
}
`
  }

  // NOTE: this code needs to be generated because otherwise it doesn't go through transforms and `@vue-router/routes`
  // cannot be resolved.
  function generateVueRouterProxy() {
    return `
import { routes } from '${MODULE_ROUTES_PATH}'
import { createRouter as _createRouter } from 'vue-router'

export * from 'vue-router'

export function createRouter(options) {
  const { extendRoutes } = options
  return _createRouter({
    ...options,
    routes: typeof extendRoutes === 'function' ? extendRoutes(routes) : routes,
  })
}
`
  }

  let lastDTS: string | undefined
  async function _writeConfigFiles() {
    log('writing')
    logTree(routeTree, log)
    if (dts) {
      const content = generateDTS()
      if (lastDTS !== content) {
        await fs.writeFile(dts, content, 'utf-8')
        lastDTS = content
        server?.invalidate(MODULE_ROUTES_PATH)
        server?.invalidate(MODULE_VUE_ROUTER)
        server?.reload()
      }
    }
  }

  // debounce of 100ms + throttle of 500ms
  // => Initially wait 100ms (renames are actually remove and add but we rather write once) (debounce)
  // subsequent calls after the first execution will wait 500ms-100ms to execute (throttling)
  const writeConfigFiles = throttle(_writeConfigFiles, 500, 100)

  function stopWatcher() {
    watchers.forEach((watcher) => watcher.close())
  }

  let server: ServerContext | undefined
  function setServerContext(_server: ServerContext) {
    server = _server
  }

  return {
    scanPages,
    writeConfigFiles,

    setServerContext,
    stopWatcher,

    generateRoutes,
    generateVueRouterProxy,
  }
}
