import chokidar from 'chokidar'
import { Options } from '../options'
import { createPrefixTree } from './tree'
import { promises as fs } from 'fs'
import { logTree, throttle } from './utils'
import { generateRouteNamedMap } from '../codegen/generateRouteMap'
import { MODULE_ROUTES_PATH, MODULE_VUE_ROUTER } from './moduleConstants'
import { generateRouteRecord } from '../codegen/generateRouteRecords'
import fg from 'fast-glob'
import { resolve } from 'pathe'
import { ServerContext } from '../options'
import { getRouteBlock } from './customBlock'

export function createRoutesContext(options: Required<Options>) {
  const { dts: preferDTS, root } = options
  const dts =
    preferDTS === false
      ? false
      : preferDTS === true
      ? resolve(root, 'typed-router.d.ts')
      : resolve(root, preferDTS)

  const routeTree = createPrefixTree(options)

  function log(...args: any[]) {
    if (options.logs) {
      console.log(...args)
    }
  }

  const resolvedRoutesFolder = resolve(root, options.routesFolder)
  const serverWatcher = chokidar.watch(resolvedRoutesFolder, {
    ignoreInitial: true,
    disableGlobbing: true,
    ignorePermissionErrors: true,
    ignored: options.exclude,
    // useFsEvents: true,
    // TODO: allow user options
  })

  function stripRouteFolder(path: string) {
    return path.slice(resolvedRoutesFolder.length + 1)
  }

  async function scanPages() {
    const routeFolders: string[] = [resolvedRoutesFolder]
    if (options.extensions.length < 1) {
      throw new Error(
        '"extensions" cannot be empty. Please specify at least one extension.'
      )
    }
    const pattern =
      `**/*` +
      (options.extensions.length === 1
        ? options.extensions[0]
        : `.{${options.extensions
            .map((extension) => extension.replace('.', ''))
            .join(',')}}`)
    const files = (
      await Promise.all(
        routeFolders.map((folder) =>
          fg(pattern, {
            cwd: folder,
            followSymbolicLinks: true,
            ignore: options.exclude,
          }).then((files) => files.flatMap((file) => resolve(folder, file)))
        )
      )
    ).flat()

    await Promise.all(files.map((file) => addPage(file)))

    await _writeConfigFiles()
  }

  async function addPage(path: string) {
    const routePath = stripRouteFolder(path)
    const routeBlock = await getRouteBlock(path, options)
    log('added', path)
    if (routeBlock) console.log(routeBlock)
    // TODO: handle top level named view HMR
    const node = routeTree.insert(
      routePath,
      // './' + path
      resolve(root, path)
    )
    node.mergeCustomRouteBlock(routeBlock)
  }

  async function updatePage(path: string) {
    const routeBlock = await getRouteBlock(path, options)
    // TODO:
    // const node = routeTree.findByPath(path)
    // node.mergeCustomRouteBlock(routeBlock)
  }

  function removePage(path: string) {
    log('remove', path)
    routeTree.remove(stripRouteFolder(path))
  }

  function setupWatcher() {
    console.log(`ü§ñ Scanning files in ${resolvedRoutesFolder}`)
    serverWatcher
      .on('change', (path) => {
        // TODO: parse defineRoute macro?
        log('change', path)
        // updatePage(path)
        // writeConfigFiles()
      })
      .on('add', async (path) => {
        await addPage(path)
        writeConfigFiles()
      })
      .on('unlink', async (path) => {
        await removePage(path)
        writeConfigFiles()
      })
  }

  function generateRoutes() {
    return `export const routes = ${generateRouteRecord(routeTree)}`
  }

  function generateDTS(): string {
    return `
// Generated by unplugin-vue-router. ‚ÄºÔ∏è DO NOT MODIFY THIS FILE ‚ÄºÔ∏è
// It's recommended to commit this file.
// Make sure to add this file to your tsconfig.json file as an "includes" or "files" entry.

/// <reference types="unplugin-vue-router/client" />

import type {
  _RouterTyped,
  RouteRecordInfo,
  RouterLinkTyped,
  RouteLocationNormalizedLoadedTypedList,
  RouteLocationAsString,
  NavigationGuard,
  _ParamValue,
  _ParamValueOneOrMore,
  _ParamValueZeroOrMore,
  _ParamValueZeroOrOne,
} from 'unplugin-vue-router'

declare module '${MODULE_ROUTES_PATH}' {
${generateRouteNamedMap(routeTree)
  .split('\n')
  .filter((line) => line)
  .map((line) => '  ' + line) // not the same as padStart(2)
  .join('\n')}
}

declare module '${MODULE_VUE_ROUTER}' {
  import type { RouteNamedMap } from '${MODULE_ROUTES_PATH}'

  export type RouterTyped = _RouterTyped<RouteNamedMap>
  /**
   * Generate a type safe route location. Requires the name of the route to be passed as a generic.
   */
  export type Route<Name extends keyof RouteNamedMap> = RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[Name]
  /**
   * Generate a type safe params for a route location. Requires the name of the route to be passed as a generic.
   */
  export type RouteParams<Name extends keyof RouteNamedMap> = RouteNamedMap[Name]['params']
  /**
   * Generate a type safe raw params for a route location. Requires the name of the route to be passed as a generic.
   */
  export type RouteParamsRaw<Name extends keyof RouteNamedMap> = RouteNamedMap[Name]['paramsRaw']

  export function useRouter(): RouterTyped
  export function useRoute<Name extends keyof RouteNamedMap = keyof RouteNamedMap>(name?: Name): RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[Name]

  export function onBeforeRouteLeave(guard: NavigationGuard<RouteNamedMap>): void
  export function onBeforeRouteUpdate(guard: NavigationGuard<RouteNamedMap>): void
}

declare module 'vue-router' {
  import type { RouteNamedMap } from '${MODULE_ROUTES_PATH}'

  export interface TypesConfig {
    beforeRouteUpdate: NavigationGuard<RouteNamedMap>
    beforeRouteLeave: NavigationGuard<RouteNamedMap>

    $route: RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[keyof RouteNamedMap]
    $router: _RouterTyped<RouteNamedMap>

    RouterLink: RouterLinkTyped<RouteNamedMap>
  }
}
`
  }

  // NOTE: this code needs to be generated because otherwise it doesn't go through transforms and `@vue-router/routes`
  // cannot be resolved.
  function generateVueRouterProxy() {
    return `
import { routes } from '${MODULE_ROUTES_PATH}'
import { createRouter as _createRouter } from 'vue-router'

export * from 'vue-router'

export function createRouter(options) {
  const { extendRoutes } = options
  return _createRouter({
    ...options,
    routes: typeof extendRoutes === 'function' ? extendRoutes(routes) : routes,
  })
}
`
  }

  let lastDTS: string | undefined
  async function _writeConfigFiles() {
    log('writing')
    logTree(routeTree, log)
    if (dts) {
      const content = generateDTS()
      if (lastDTS !== content) {
        await fs.writeFile(dts, content, 'utf-8')
        lastDTS = content
        server?.invalidate(MODULE_ROUTES_PATH)
        server?.invalidate(MODULE_VUE_ROUTER)
        server?.reload()
      }
    }
  }

  // debounce of 100ms + throttle of 500ms
  // => Initially wait 100ms (renames are actually remove and add but we rather write once) (debounce)
  // subsequent calls after the first execution will wait 500ms-100ms to execute (throttling)
  const writeConfigFiles = throttle(_writeConfigFiles, 500, 100)

  setupWatcher()

  function stopWatcher() {
    serverWatcher.close()
  }

  let server: ServerContext | undefined
  function setServerContext(_server: ServerContext) {
    server = _server
  }

  return {
    scanPages,
    writeConfigFiles,

    setServerContext,
    stopWatcher,

    generateRoutes,
    generateVueRouterProxy,
  }
}
